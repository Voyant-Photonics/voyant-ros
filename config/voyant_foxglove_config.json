{
  "configById": {
    "3D!2sx8isc": {
      "cameraState": {
        "perspective": true,
        "distance": 19.999999999999517,
        "phi": 64.51882845188278,
        "thetaOffset": 75.12552301255258,
        "targetOffset": [
          0,
          0,
          0
        ],
        "target": [
          0,
          0,
          0
        ],
        "targetOrientation": [
          0,
          0,
          0,
          1
        ],
        "fovy": 45,
        "near": 0.5,
        "far": 5000
      },
      "followMode": "follow-pose",
      "scene": {},
      "transforms": {},
      "topics": {
        "/rng_color_pointcloud": {
          "visible": true,
          "colorField": "z",
          "colorMode": "rgba-fields",
          "colorMap": "turbo"
        }
      },
      "layers": {
        "grid": {
          "visible": false,
          "frameLocked": true,
          "label": "Grid",
          "instanceId": "ecaed21f-7934-4d7c-a22e-afcf003d23a9",
          "layerId": "foxglove.Grid",
          "size": 10,
          "divisions": 10,
          "lineWidth": 1,
          "color": "#248eff",
          "position": [
            0,
            0,
            0
          ],
          "rotation": [
            0,
            0,
            0
          ]
        }
      },
      "publish": {
        "type": "point",
        "poseTopic": "/move_base_simple/goal",
        "pointTopic": "/clicked_point",
        "poseEstimateTopic": "/initialpose",
        "poseEstimateXDeviation": 0.5,
        "poseEstimateYDeviation": 0.5,
        "poseEstimateThetaDeviation": 0.26179939
      },
      "imageMode": {}
    },
    "3D!16e5wyi": {
      "cameraState": {
        "perspective": true,
        "distance": 14.701837812499429,
        "phi": 59.23076923076902,
        "thetaOffset": 85.00000000000023,
        "targetOffset": [
          -0.30155450193471844,
          0.25050557490840863,
          -4.333926816958914e-18
        ],
        "target": [
          0,
          0,
          0
        ],
        "targetOrientation": [
          0,
          0,
          0,
          1
        ],
        "fovy": 45,
        "near": 0.5,
        "far": 5000
      },
      "followMode": "follow-pose",
      "scene": {},
      "transforms": {},
      "topics": {
        "/snr_color_pointcloud": {
          "visible": true,
          "colorField": "red",
          "colorMode": "rgba-fields",
          "colorMap": "turbo"
        }
      },
      "layers": {
        "grid": {
          "visible": false,
          "frameLocked": true,
          "label": "Grid",
          "instanceId": "988c292c-31c5-4a9c-83f5-70be0b2a7b43",
          "layerId": "foxglove.Grid",
          "size": 10,
          "divisions": 10,
          "lineWidth": 1,
          "color": "#248eff",
          "position": [
            0,
            0,
            0
          ],
          "rotation": [
            0,
            0,
            0
          ]
        }
      },
      "publish": {
        "type": "point",
        "poseTopic": "/move_base_simple/goal",
        "pointTopic": "/clicked_point",
        "poseEstimateTopic": "/initialpose",
        "poseEstimateXDeviation": 0.5,
        "poseEstimateYDeviation": 0.5,
        "poseEstimateThetaDeviation": 0.26179939
      },
      "imageMode": {}
    },
    "3D!15kvggn": {
      "cameraState": {
        "perspective": true,
        "distance": 14.701837812499617,
        "phi": 50.76923076923064,
        "thetaOffset": 81.15384615384626,
        "targetOffset": [
          0.12169155697834566,
          0.12169155697834566,
          0
        ],
        "target": [
          0,
          0,
          0
        ],
        "targetOrientation": [
          0,
          0,
          0,
          1
        ],
        "fovy": 45,
        "near": 0.5,
        "far": 5000
      },
      "followMode": "follow-pose",
      "scene": {},
      "transforms": {},
      "topics": {
        "/snr_color_pointcloud": {
          "visible": false,
          "colorField": "red",
          "colorMode": "rgba-fields",
          "colorMap": "turbo"
        },
        "/dop_color_pointcloud": {
          "visible": true,
          "colorField": "z",
          "colorMode": "rgba-fields",
          "colorMap": "turbo"
        }
      },
      "layers": {
        "grid": {
          "visible": false,
          "frameLocked": true,
          "label": "Grid",
          "instanceId": "988c292c-31c5-4a9c-83f5-70be0b2a7b43",
          "layerId": "foxglove.Grid",
          "size": 10,
          "divisions": 10,
          "lineWidth": 1,
          "color": "#248eff",
          "position": [
            0,
            0,
            0
          ],
          "rotation": [
            0,
            0,
            0
          ]
        }
      },
      "publish": {
        "type": "point",
        "poseTopic": "/move_base_simple/goal",
        "pointTopic": "/clicked_point",
        "poseEstimateTopic": "/initialpose",
        "poseEstimateXDeviation": 0.5,
        "poseEstimateYDeviation": 0.5,
        "poseEstimateThetaDeviation": 0.26179939
      },
      "imageMode": {}
    },
    "GlobalVariableSliderPanel!2e7ijri": {
      "sliderProps": {
        "min": 0,
        "max": 100,
        "step": 0.1
      },
      "globalVariableName": "max_snr_bound",
      "foxglovePanelTitle": "SNR Max Bound (dB)"
    },
    "GlobalVariableSliderPanel!3qbvnjm": {
      "sliderProps": {
        "min": 0,
        "max": 100,
        "step": 0.1
      },
      "globalVariableName": "min_snr_bound",
      "foxglovePanelTitle": "SNR Min Bound (dB)"
    },
    "GlobalVariableSliderPanel!3q2vfoj": {
      "sliderProps": {
        "min": 5,
        "max": 200,
        "step": 0.5
      },
      "globalVariableName": "range_band",
      "foxglovePanelTitle": "Range Band (m)"
    },
    "GlobalVariableSliderPanel!2gxsope": {
      "sliderProps": {
        "min": 0,
        "max": 3,
        "step": 0.1
      },
      "globalVariableName": "min_dop_bound",
      "foxglovePanelTitle": "Doppler Min bound -ve(m/s)"
    },
    "GlobalVariableSliderPanel!5wqrfj": {
      "sliderProps": {
        "min": 0,
        "max": 3,
        "step": 0.1
      },
      "globalVariableName": "max_dop_bound",
      "foxglovePanelTitle": "Doppler Max bound (m/s)"
    },
    "3D!2guf9vc": {
      "cameraState": {
        "perspective": true,
        "distance": 19.999999999999886,
        "phi": 61.506276150627556,
        "thetaOffset": 59.30962343096235,
        "targetOffset": [
          0,
          0,
          0
        ],
        "target": [
          0,
          0,
          0
        ],
        "targetOrientation": [
          0,
          0,
          0,
          1
        ],
        "fovy": 45,
        "near": 0.5,
        "far": 5000
      },
      "followMode": "follow-pose",
      "scene": {},
      "transforms": {},
      "topics": {
        "/voyant_points": {
          "visible": true,
          "colorField": "z",
          "colorMode": "colormap",
          "colorMap": "turbo"
        }
      },
      "layers": {
        "grid": {
          "visible": false,
          "frameLocked": true,
          "label": "Grid",
          "instanceId": "ecaed21f-7934-4d7c-a22e-afcf003d23a9",
          "layerId": "foxglove.Grid",
          "size": 10,
          "divisions": 10,
          "lineWidth": 1,
          "color": "#248eff",
          "position": [
            0,
            0,
            0
          ],
          "rotation": [
            0,
            0,
            0
          ]
        }
      },
      "publish": {
        "type": "point",
        "poseTopic": "/move_base_simple/goal",
        "pointTopic": "/clicked_point",
        "poseEstimateTopic": "/initialpose",
        "poseEstimateXDeviation": 0.5,
        "poseEstimateYDeviation": 0.5,
        "poseEstimateThetaDeviation": 0.26179939
      },
      "imageMode": {}
    }
  },
  "globalVariables": {
    "globalVariable": 2,
    "min_SNR_bound": 5,
    "min_snr_bound": 100,
    "max_snr_bound": 100,
    "min_dop_bound": 3,
    "max_dop_bound": 3,
    "range_band": 5
  },
  "userNodes": {
    "869d30d4-e1a0-4e9f-aea6-f6dc80f4858a": {
      "sourceCode": "import { Input } from \"./types\";\nimport { PointCloud, PackedElementField } from \"@foxglove/schemas\";\n\n// Constants for point cloud field types\nconst FIELD_TYPE = {\n  UINT8: 1,\n  UINT16: 2,\n  UINT32: 5,\n  INT32: 6,\n  FLOAT32: 7,\n};\n\n// SNR color configuration\nconst SNR_COLORS: [number, number, number][] = [\n  [7, 107, 236], // Low SNR (blue)\n  [255, 0, 127], // Mid SNR (magenta)\n  [255, 204, 0], // High SNR (yellow)\n];\n\n// Define input and output topics\nexport const inputs = [\"/voyant_points\"];\nexport const output = \"/snr_color_pointcloud\";\n\n// Global variables interface\ninterface GlobalVariables {\n  min_snr_bound: number;\n  max_snr_bound: number;\n}\n\n/**\n * Creates a linear color mapping between three colors\n * @param colors Array of three [r,g,b] colors representing low, mid, and high values\n * @returns A 256-entry color map with interpolated values\n */\nfunction createLinearColorMap(colors: [number, number, number][]): number[][] {\n  if (colors.length !== 3) {\n    throw new Error(\"Color map requires exactly 3 colors (low, mid, high)\");\n  }\n\n  const [colorLow, colorMid, colorHigh] = colors;\n  const colorMap: number[][] = [];\n\n  // Create 256 interpolated colors\n  for (let i = 0; i < 256; i++) {\n    const normVal = i / 255;\n    let r, g, b;\n\n    if (normVal < 0.5) {\n      // Interpolate between low and mid colors\n      const factor = normVal * 2;\n      r = colorLow[0] + factor * (colorMid[0] - colorLow[0]);\n      g = colorLow[1] + factor * (colorMid[1] - colorLow[1]);\n      b = colorLow[2] + factor * (colorMid[2] - colorLow[2]);\n    } else {\n      // Interpolate between mid and high colors\n      const factor = (normVal - 0.5) * 2;\n      r = colorMid[0] + factor * (colorHigh[0] - colorMid[0]);\n      g = colorMid[1] + factor * (colorHigh[1] - colorMid[1]);\n      b = colorMid[2] + factor * (colorHigh[2] - colorMid[2]);\n    }\n\n    colorMap.push([Math.round(r), Math.round(g), Math.round(b)]);\n  }\n\n  return colorMap;\n}\n\n/**\n * Converts SNR values to RGB colors using the provided color map\n * @param colorMap The color map to use for conversion\n * @param snrValues Array of SNR values\n * @param minSnr Minimum SNR value for normalization\n * @param maxSnr Maximum SNR value for normalization\n * @returns Array of RGB values corresponding to the input SNR values\n */\nfunction mapSnrToRgb(\n  colorMap: number[][],\n  snrValues: number[],\n  minSnr: number,\n  maxSnr: number,\n): number[][] {\n  // Find actual min/max within bounds\n  const validMin = Math.max(minSnr, Math.min(...snrValues));\n  const validMax = Math.min(maxSnr, Math.max(...snrValues));\n  const range = validMax - validMin;\n\n  return snrValues.map((value) => {\n    // Clip to min/max bounds\n    const clippedValue = Math.min(Math.max(value, validMin), validMax);\n\n    // Normalize to 0-255 range\n    const normalizedValue =\n      range === 0\n        ? 128 // Default to middle value if range is zero\n        : ((clippedValue - validMin) / range) * 255;\n\n    // Get color map index (ensuring it's within bounds)\n    const index = Math.min(Math.max(Math.round(normalizedValue), 0), 255);\n\n    return colorMap[index];\n  });\n}\n\n/**\n * Converts a 4-byte Uint8Array to a Float32 value\n * @param bytes 4-byte Uint8Array\n * @returns Float32 value\n */\nfunction bytesToFloat32(bytes: Uint8Array): number {\n  const dataView = new DataView(bytes.buffer, bytes.byteOffset, 4);\n  return dataView.getFloat32(0, true); // true for little-endian\n}\n\n// Define the point cloud fields including the added RGBA fields\nconst POINT_CLOUD_FIELDS: PackedElementField[] = [\n  { name: \"x\", offset: 0, type: FIELD_TYPE.FLOAT32 },\n  { name: \"y\", offset: 4, type: FIELD_TYPE.FLOAT32 },\n  { name: \"z\", offset: 8, type: FIELD_TYPE.FLOAT32 },\n  { name: \"v\", offset: 16, type: FIELD_TYPE.FLOAT32 },\n  { name: \"snr\", offset: 20, type: FIELD_TYPE.FLOAT32 },\n  { name: \"drop_reason\", offset: 24, type: FIELD_TYPE.UINT16 },\n  { name: \"timestamp_nsecs\", offset: 26, type: FIELD_TYPE.INT32 },\n  { name: \"point_idx\", offset: 30, type: FIELD_TYPE.UINT32 },\n  { name: \"red\", offset: 48, type: FIELD_TYPE.UINT8 },\n  { name: \"green\", offset: 49, type: FIELD_TYPE.UINT8 },\n  { name: \"blue\", offset: 50, type: FIELD_TYPE.UINT8 },\n  { name: \"alpha\", offset: 51, type: FIELD_TYPE.UINT8 },\n];\n\n/**\n * Main script function to process point cloud data and color it based on SNR values\n * @param event Input event containing LiDAR point cloud data\n * @param globalVars Global variables for SNR bounds\n * @returns Modified point cloud with added color information\n */\nexport default function script(\n  event: Input<\"/voyant_points\">,\n  globalVars: GlobalVariables,\n): PointCloud {\n  const { data, point_step: originalStride } = event.message;\n  const numPoints = data.length / originalStride;\n\n  // Calculate new stride with RGBA fields\n  const newStride = originalStride + 4; // Adding 4 bytes for RGBA\n  const newDataSize = numPoints * newStride;\n\n  // Extract SNR values from all points\n  const snrValues = extractSnrValues(data, originalStride, numPoints);\n\n  // Create SNR color map and convert SNR values to RGB colors\n  const colorMap = createLinearColorMap(SNR_COLORS);\n  const rgbColors = mapSnrToRgb(\n    colorMap,\n    snrValues,\n    globalVars.min_snr_bound,\n    globalVars.max_snr_bound,\n  );\n\n  // Create the new point cloud data with added color information\n  const coloredPointCloud = createColoredPointCloud(\n    data,\n    rgbColors,\n    originalStride,\n    newStride,\n    numPoints,\n  );\n\n  // Return the modified point cloud message\n  return {\n    timestamp: {\n      sec: event.message.header.stamp.sec,\n      nsec: event.message.header.stamp.nsec,\n    },\n    frame_id: event.message.header.frame_id,\n    pose: {\n      position: { x: 0, y: 0, z: 0 },\n      orientation: { x: 0, y: 0, z: 0, w: 1 },\n    },\n    point_stride: newStride,\n    fields: POINT_CLOUD_FIELDS,\n    data: coloredPointCloud,\n  };\n}\n\n/**\n * Extracts SNR values from point cloud data\n * @param data Original point cloud data\n * @param stride Original point stride\n * @param numPoints Number of points\n * @returns Array of SNR values\n */\nfunction extractSnrValues(\n  data: Uint8Array,\n  stride: number,\n  numPoints: number,\n): number[] {\n  const snrValues: number[] = [];\n  const SNR_OFFSET = 20; // Offset to SNR value in each point\n\n  for (let i = 0; i < numPoints; i++) {\n    const pointOffset = i * stride;\n    const snrBytes = data.slice(\n      pointOffset + SNR_OFFSET,\n      pointOffset + SNR_OFFSET + 4,\n    );\n    const snrValue = bytesToFloat32(snrBytes);\n    snrValues.push(snrValue);\n  }\n\n  return snrValues;\n}\n\n/**\n * Creates a new point cloud with added color information\n * @param originalData Original point cloud data\n * @param rgbColors RGB colors to apply to each point\n * @param originalStride Original point stride\n * @param newStride New point stride (with RGBA fields)\n * @param numPoints Number of points\n * @returns New point cloud data with colors\n */\nfunction createColoredPointCloud(\n  originalData: Uint8Array,\n  rgbColors: number[][],\n  originalStride: number,\n  newStride: number,\n  numPoints: number,\n): Uint8Array {\n  const coloredData = new Uint8Array(numPoints * newStride);\n  const RGBA_OFFSET = 48; // Offset to RGBA values in new point structure\n\n  for (let i = 0; i < numPoints; i++) {\n    // Copy original point data\n    const srcOffset = i * originalStride;\n    const destOffset = i * newStride;\n    coloredData.set(\n      originalData.subarray(srcOffset, srcOffset + originalStride),\n      destOffset,\n    );\n\n    // Add RGB and alpha values\n    const [r, g, b] = rgbColors[i];\n    coloredData.set([r, g, b, 255], destOffset + RGBA_OFFSET);\n  }\n\n  return coloredData;\n}\n",
      "name": "snr_clr_add_fields.ts"
    },
    "87132b73-8226-4e15-9e26-b4dd44475001": {
      "sourceCode": "import { Input } from \"./types\";\nimport { PointCloud, PackedElementField } from \"@foxglove/schemas\";\n\n// Constants for point cloud field types\nconst FIELD_TYPE = {\n  UINT8: 1,\n  UINT16: 2,\n  UINT32: 5,\n  INT32: 6,\n  FLOAT32: 7,\n};\n\n// Constants for input/output topics and field types\nexport const inputs = [\"/voyant_points\"];\nexport const output = \"/dop_color_pointcloud\";\n\n// Type definitions\ntype GlobalVariables = {\n  min_dop_bound: number;\n  max_dop_bound: number;\n};\n\ntype RGBColor = [number, number, number];\n\n// Data structures for point cloud fields\nconst POINT_FIELDS: PackedElementField[] = [\n  { name: \"x\", offset: 0, type: FIELD_TYPE.FLOAT32 },\n  { name: \"y\", offset: 4, type: FIELD_TYPE.FLOAT32 },\n  { name: \"z\", offset: 8, type: FIELD_TYPE.FLOAT32 },\n  { name: \"v\", offset: 16, type: FIELD_TYPE.FLOAT32 },\n  { name: \"snr\", offset: 20, type: FIELD_TYPE.FLOAT32 },\n  { name: \"drop_reason\", offset: 24, type: FIELD_TYPE.UINT16 },\n  { name: \"timestamp_nsecs\", offset: 26, type: FIELD_TYPE.INT32 },\n  { name: \"point_idx\", offset: 30, type: FIELD_TYPE.UINT32 },\n  { name: \"red\", offset: 48, type: FIELD_TYPE.UINT8 },\n  { name: \"green\", offset: 49, type: FIELD_TYPE.UINT8 },\n  { name: \"blue\", offset: 50, type: FIELD_TYPE.UINT8 },\n  { name: \"alpha\", offset: 51, type: FIELD_TYPE.UINT8 },\n];\n\n// Color constants\nconst DOPPLER_COLORS: RGBColor[] = [\n  [255.0, 0.0, 0.0], // Red for negative doppler (moving away)\n  [49.0, 49.0, 49.0], // Gray for zero doppler\n  [0.0, 100.0, 255.0], // Blue for positive doppler (moving toward)\n];\n\n// Pre-compute the color map\nconst dopColorMap = createLinearColorMap(DOPPLER_COLORS);\n\n/**\n * Creates a linear color gradient map between given color points\n * @param colors Array of RGB triplets defining the gradient points\n * @returns 2D array with 256 RGB color values\n */\nfunction createLinearColorMap(colors: RGBColor[]): number[][] {\n  // Extract colors from the input array\n  const [colorLow, colorMid, colorHigh] = colors;\n  const colorMap: number[][] = [];\n\n  // Create 256 interpolated colors\n  for (let i = 0; i < 256; i++) {\n    const normVal = i / 255.0;\n    let r, g, b;\n\n    if (normVal < 0.5) {\n      // Interpolate between low and mid\n      const factor = normVal * 2.0;\n      r = interpolate(colorLow[0], colorMid[0], factor);\n      g = interpolate(colorLow[1], colorMid[1], factor);\n      b = interpolate(colorLow[2], colorMid[2], factor);\n    } else {\n      // Interpolate between mid and high\n      const factor = (normVal - 0.5) * 2.0;\n      r = interpolate(colorMid[0], colorHigh[0], factor);\n      g = interpolate(colorMid[1], colorHigh[1], factor);\n      b = interpolate(colorMid[2], colorHigh[2], factor);\n    }\n\n    colorMap.push([r, g, b]);\n  }\n\n  return colorMap;\n}\n\n/**\n * Linear interpolation between two values\n * @param a Starting value\n * @param b Ending value\n * @param t Interpolation factor (0.0 to 1.0)\n * @returns Interpolated value\n */\nfunction interpolate(a: number, b: number, t: number): number {\n  return a + t * (b - a);\n}\n\n/**\n * Maps doppler velocity values to RGB colors using a predefined color map\n * @param colorMap The color mapping array (256 RGB values)\n * @param velocities Array of doppler velocity values\n * @param minDoppler Minimum doppler value for normalization\n * @param maxDoppler Maximum doppler value for normalization\n * @returns Array of RGB color values corresponding to input velocities\n */\nfunction mapDopplerToRGB(\n  colorMap: number[][],\n  velocities: number[],\n  minDoppler: number,\n  maxDoppler: number,\n): number[][] {\n  // Ensure min is negative (moving away) and max is positive (moving toward)\n  const minDop = -Math.abs(minDoppler);\n  const maxDop = Math.abs(maxDoppler);\n  const dopplerRange = maxDop - minDop;\n\n  return velocities.map((velocity) => {\n    // Normalize velocity to 0-255 range\n    const normalizedValue = Math.max(\n      0,\n      Math.min(255, Math.round(((velocity - minDop) / dopplerRange) * 255)),\n    );\n\n    // Return the corresponding color from the map with safe fallback\n    return colorMap[normalizedValue] || [0, 0, 0];\n  });\n}\n\n/**\n * Converts a 4-byte Uint8Array to a Float32 value\n * @param bytes 4-byte Uint8Array containing the float data\n * @returns Parsed float32 value\n */\nfunction uint8ArrayToFloat32(bytes: Uint8Array): number {\n  return new DataView(bytes.buffer).getFloat32(0, true); // true for little-endian\n}\n\n/**\n * Main script function to process point cloud data\n * @param event Input point cloud message\n * @param globalVars User-configurable parameters\n * @returns Processed point cloud with color data\n */\nexport default function script(\n  event: Input<\"/voyant_points\">,\n  globalVars: GlobalVariables,\n): PointCloud {\n  const { data } = event.message;\n  const oldStride = event.message.point_step;\n  const newStride = oldStride + 4; // Adding 4 bytes for RGBA\n  const numPoints = Math.floor(data.length / oldStride);\n\n  // Extract doppler values from point cloud\n  const dopplerValues = extractDopplerValues(data, oldStride, numPoints);\n\n  // Map doppler values to RGB colors\n  const dopplerColors = mapDopplerToRGB(\n    dopColorMap,\n    dopplerValues,\n    globalVars.min_dop_bound,\n    globalVars.max_dop_bound,\n  );\n\n  // Create new point cloud with color data\n  const newPointCloud = createColorizedPointCloud(\n    data,\n    dopplerColors,\n    oldStride,\n    newStride,\n    numPoints,\n  );\n\n  return {\n    timestamp: {\n      sec: event.message.header.stamp.sec,\n      nsec: event.message.header.stamp.nsec,\n    },\n    frame_id: event.message.header.frame_id,\n    pose: {\n      position: { x: 0, y: 0, z: 0 },\n      orientation: { x: 0, y: 0, z: 0, w: 1 },\n    },\n    point_stride: newStride,\n    fields: POINT_FIELDS,\n    data: newPointCloud,\n  };\n}\n\n/**\n * Extracts doppler velocity values from point cloud data\n * @param data Raw point cloud data\n * @param stride Point stride in bytes\n * @param numPoints Number of points in the cloud\n * @returns Array of doppler velocity values\n */\nfunction extractDopplerValues(\n  data: Uint8Array,\n  stride: number,\n  numPoints: number,\n): number[] {\n  const dopplerValues: number[] = [];\n  const DOPPLER_OFFSET = 16; // Doppler field offset in bytes\n\n  for (let i = 0; i < numPoints; i++) {\n    const pointOffset = i * stride;\n    const dopplerBytes = new Uint8Array(4);\n    dopplerBytes.set(\n      data.subarray(\n        pointOffset + DOPPLER_OFFSET,\n        pointOffset + DOPPLER_OFFSET + 4,\n      ),\n    );\n    dopplerValues.push(uint8ArrayToFloat32(dopplerBytes));\n  }\n\n  return dopplerValues;\n}\n\n/**\n * Creates a new point cloud with colorized points\n * @param sourceData Original point cloud data\n * @param colors RGB color values for each point\n * @param oldStride Original point stride in bytes\n * @param newStride New point stride in bytes\n * @param numPoints Number of points in the cloud\n * @returns New Uint8Array with original data plus colors\n */\nfunction createColorizedPointCloud(\n  sourceData: Uint8Array,\n  colors: number[][],\n  oldStride: number,\n  newStride: number,\n  numPoints: number,\n): Uint8Array {\n  const newSize = numPoints * newStride;\n  const newData = new Uint8Array(newSize);\n\n  for (let i = 0; i < numPoints; i++) {\n    const srcOffset = i * oldStride;\n    const dstOffset = i * newStride;\n\n    // Copy original point data\n    newData.set(\n      sourceData.subarray(srcOffset, srcOffset + oldStride),\n      dstOffset,\n    );\n\n    // Add color data\n    if (i < colors.length && colors[i]) {\n      const [r, g, b] = colors[i].map((v) =>\n        Math.round(Math.max(0, Math.min(255, v))),\n      );\n      newData.set([r, g, b, 255], dstOffset + oldStride);\n    } else {\n      // Fallback color if data is missing\n      newData.set([128, 128, 128, 255], dstOffset + oldStride);\n    }\n  }\n\n  return newData;\n}\n",
      "name": "dop_clr_add_fields.ts"
    },
    "0951bbfe-4683-437a-84e1-102e7f204624": {
      "sourceCode": "import { Input } from \"./types\";\nimport { PointCloud, PackedElementField } from \"@foxglove/schemas\";\n\n// Define constants\nconst BYTE_SIZE = {\n  FLOAT32: 4,\n  UINT8: 1,\n};\n\nconst COLOR_MAP_SIZE = 255;\nconst MAX_HUE = 360;\nconst MAX_SATURATION = 100;\nconst MAX_VALUE = 100;\nconst ALPHA_MAX = 255;\n\n// Export script configuration\nexport const inputs = [\"/voyant_points\"];\nexport const output = \"/rng_color_pointcloud\";\n\ninterface GlobalVariables {\n  range_band: number;\n}\n\ninterface RGB {\n  r: number;\n  g: number;\n  b: number;\n}\n\n/**\n * Converts HSV color values to RGB\n * @param h - Hue (0-360)\n * @param s - Saturation (0-100)\n * @param v - Value (0-100)\n * @returns RGB color object with values 0-255\n */\nfunction hsvToRgb(h: number, s: number, v: number): RGB {\n  // Normalize values to [0,1] range\n  const hNorm = h / MAX_HUE;\n  const sNorm = s / MAX_SATURATION;\n  const vNorm = v / MAX_VALUE;\n\n  const i = Math.floor(hNorm * 6);\n  const f = hNorm * 6 - i;\n  const p = vNorm * (1 - sNorm);\n  const q = vNorm * (1 - f * sNorm);\n  const t = vNorm * (1 - (1 - f) * sNorm);\n\n  let r = 0,\n    g = 0,\n    b = 0;\n  switch (i % 6) {\n    case 0:\n      r = vNorm;\n      g = t;\n      b = p;\n      break;\n    case 1:\n      r = q;\n      g = vNorm;\n      b = p;\n      break;\n    case 2:\n      r = p;\n      g = vNorm;\n      b = t;\n      break;\n    case 3:\n      r = p;\n      g = q;\n      b = vNorm;\n      break;\n    case 4:\n      r = t;\n      g = p;\n      b = vNorm;\n      break;\n    case 5:\n      r = vNorm;\n      g = p;\n      b = q;\n      break;\n  }\n\n  return {\n    r: Math.round(r * 255),\n    g: Math.round(g * 255),\n    b: Math.round(b * 255),\n  };\n}\n\n/**\n * Converts a Uint8Array (4 bytes) to a Float32 value\n * @param bytes - Uint8Array containing 4 bytes\n * @returns Float32 value\n */\nfunction uint8ArrayToFloat32(bytes: Uint8Array): number {\n  const dataView = new DataView(bytes.buffer);\n  return dataView.getFloat32(0, true); // true for little-endian\n}\n\n/**\n * Creates a cyclic color map with evenly distributed hues\n * @param numColors - Number of colors in the map\n * @param saturation - Saturation value (0-100)\n * @param value - Brightness value (0-100)\n * @returns 2D array of RGB values [r,g,b]\n */\nfunction createCyclicColorMap(\n  numColors: number,\n  saturation: number,\n  value: number,\n): number[][] {\n  const colorMap: number[][] = [];\n\n  for (let i = 0; i < numColors; i++) {\n    const hue = (i / numColors) * MAX_HUE;\n    const { r, g, b } = hsvToRgb(hue, saturation, value);\n    colorMap.push([r, g, b]);\n  }\n\n  return colorMap;\n}\n\n/**\n * Maps range values to RGB colors using the provided color map\n * @param colorMap - 2D array of RGB values\n * @param rangeValues - Array of range values to map\n * @param bandSize - Size of each color band\n * @returns 2D array of RGB values for each input range value\n */\nfunction mapRangeToRgb(\n  colorMap: number[][],\n  rangeValues: number[],\n  bandSize: number,\n): number[][] {\n  // Normalize ranges into bands\n  const normalizedValues = rangeValues.map(\n    (val) => (val % bandSize) / bandSize,\n  );\n\n  // Map normalized values to color indices\n  const colorIndices = normalizedValues.map((val) =>\n    Math.floor(val * (COLOR_MAP_SIZE - 1)),\n  );\n\n  // Return RGB values from the color map\n  return colorIndices.map((index) => {\n    if (index >= 0 && index < colorMap.length) {\n      return colorMap[index];\n    }\n    return [0, 0, 0]; // Fallback for out-of-range indices\n  });\n}\n\n// Create a color map once for reuse\nconst rangeColorMap: number[][] = createCyclicColorMap(\n  COLOR_MAP_SIZE,\n  MAX_SATURATION,\n  MAX_VALUE,\n);\n\n// Define point cloud field structure\nconst pointCloudFields: PackedElementField[] = [\n  { name: \"x\", offset: 0, type: 7 },\n  { name: \"y\", offset: 4, type: 7 },\n  { name: \"z\", offset: 8, type: 7 },\n  { name: \"v\", offset: 16, type: 7 },\n  { name: \"snr\", offset: 20, type: 7 },\n  { name: \"drop_reason\", offset: 24, type: 2 },\n  { name: \"timestamp_nsecs\", offset: 26, type: 6 },\n  { name: \"point_idx\", offset: 30, type: 5 },\n  { name: \"red\", offset: 48, type: 1 },\n  { name: \"green\", offset: 49, type: 1 },\n  { name: \"blue\", offset: 50, type: 1 },\n  { name: \"alpha\", offset: 51, type: 1 },\n];\n\n/**\n * Main script function that processes the point cloud data\n * @param event - Input event containing the point cloud message\n * @param globalVars - Global variables including range_band\n * @returns Modified point cloud with color data\n */\nexport default function script(\n  event: Input<\"/voyant_points\">,\n  globalVars: GlobalVariables,\n): PointCloud {\n  const originalData = event.message.data;\n  const originalStride = event.message.point_step;\n  const newStride = originalStride + 4 * BYTE_SIZE.UINT8; // Adding RGBA fields (4 bytes)\n  const numPoints = Math.floor(originalData.length / originalStride);\n  const newSize = numPoints * newStride;\n\n  // Extract range values from the original point cloud\n  const rangeValues: number[] = [];\n  for (let i = 0; i < originalData.length; i += originalStride) {\n    if (i + BYTE_SIZE.FLOAT32 <= originalData.length) {\n      const rangeBytes = new Uint8Array(BYTE_SIZE.FLOAT32);\n      rangeBytes.set(originalData.subarray(i, i + BYTE_SIZE.FLOAT32));\n      rangeValues.push(uint8ArrayToFloat32(rangeBytes));\n    }\n  }\n\n  // Map range values to colors\n  const colorValues = mapRangeToRgb(\n    rangeColorMap,\n    rangeValues,\n    globalVars.range_band,\n  );\n\n  // Create new data buffer for the output point cloud\n  const newPointCloudData = new Uint8Array(newSize);\n\n  // Copy original data and add color information\n  for (let i = 0; i < numPoints; i++) {\n    const originalOffset = i * originalStride;\n    const newOffset = i * newStride;\n\n    // Copy original point data\n    newPointCloudData.set(\n      originalData.subarray(originalOffset, originalOffset + originalStride),\n      newOffset,\n    );\n\n    // Add color information\n    const color = i < colorValues.length ? colorValues[i] : [0, 0, 0];\n    newPointCloudData.set(\n      [\n        color[0] || 0, // Red\n        color[1] || 0, // Green\n        color[2] || 0, // Blue\n        ALPHA_MAX, // Alpha (fully opaque)\n      ],\n      newOffset + 48,\n    );\n  }\n\n  // Return the modified point cloud\n  return {\n    timestamp: {\n      sec: event.message.header.stamp.sec,\n      nsec: event.message.header.stamp.nsec,\n    },\n    frame_id: event.message.header.frame_id,\n    pose: {\n      position: { x: 0, y: 0, z: 0 },\n      orientation: { x: 0, y: 0, z: 0, w: 1 },\n    },\n    point_stride: newStride,\n    fields: pointCloudFields,\n    data: newPointCloudData,\n  };\n}\n",
      "name": "rng_clr_band_add_fields.ts"
    }
  },
  "playbackConfig": {
    "speed": 1
  },
  "layout": {
    "first": {
      "first": {
        "first": "3D!2guf9vc",
        "second": "3D!2sx8isc",
        "direction": "row",
        "splitPercentage": 49.97737766445291
      },
      "second": {
        "first": "3D!16e5wyi",
        "second": "3D!15kvggn",
        "direction": "row"
      },
      "direction": "column",
      "splitPercentage": 51.98776758409785
    },
    "second": {
      "first": {
        "first": "GlobalVariableSliderPanel!2e7ijri",
        "second": {
          "first": {
            "first": "GlobalVariableSliderPanel!3qbvnjm",
            "second": "GlobalVariableSliderPanel!3q2vfoj",
            "direction": "column"
          },
          "second": "GlobalVariableSliderPanel!2gxsope",
          "direction": "column",
          "splitPercentage": 70.70413355726568
        },
        "direction": "column",
        "splitPercentage": 23.87267904509284
      },
      "second": "GlobalVariableSliderPanel!5wqrfj",
      "direction": "column",
      "splitPercentage": 77.13382507903056
    },
    "direction": "row",
    "splitPercentage": 87.79697624190065
  }
}